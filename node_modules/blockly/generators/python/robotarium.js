/**
 * @license
 * Copyright 2012 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Generating Python for variable blocks.
 * @author q.neutron@gmail.com (Quynh Neutron)
 */
 'use strict';

// Ititialize sets up the Robotarium Libraties and imports all of  the required files


 Blockly.Python['initialize'] = function(block) {
   var code = `
from turtle import position
import rps.robotarium as robotarium
from rps.utilities.transformations import *
from rps.utilities.barrier_certificates import *
from rps.utilities.misc import *
from rps.utilities.controllers import *

import numpy as np
import time
import math

class Robot:

    def __init__(self, name, x, y, t):
        self.target_points = []
        self.currentPoint = 0
        self.totalPoints = 0
        self.finished = False
        self.output_points = np.array([[],[],[]])
        t=t%360
        if(t>180):
            t=t-360
        theta = t * 3.14/180
        self.name = name
        self.start_array = np.array([[x],[y],[theta]])
        self.target_points.append((x,y,theta))
        self.output_points = np.array([[x],[y],[theta]])
    
    def add_Target_Point(self,x,y,t):
        self.totalPoints = self.totalPoints + 1
        t=t%360
        if(t>180):
            t=t-360
        self.target_points.append((x,y,t*3.14/180))

    def get_Target_Points(self):
        return self.target_points

    def update_Output_Points(self):
        self.output_points[0] = self.target_points[self.currentPoint][0]
        self.output_points[1] = self.target_points[self.currentPoint][1]
        self.output_points[2] = self.target_points[self.currentPoint][2]
    
    def step_Current_Point(self):
        self.currentPoint = self.currentPoint + 1
        if(self.currentPoint > self.totalPoints):
            self.finished = True
        if(not self.finished):
            self.update_Output_Points()
    
    def get_Output_Points(self):
        return self.output_points

    def angle_In_Range(self, angle, accuracy = .07):
        if((self.target_points[self.currentPoint][2]-accuracy<angle<self.target_points[self.currentPoint][2]+accuracy)):
            return True
        else:
            return False

    def check_Position(self,robot_num, pos, accuracy = .03):
        if(not self.finished):
            if((self.target_points[self.currentPoint][0]-accuracy< pos[0][robot_num] < self.target_points[self.currentPoint][0]+accuracy) and (self.target_points[self.currentPoint][1]-accuracy< pos[1][robot_num] < self.target_points[self.currentPoint][1]+accuracy) and (self.angle_In_Range(pos[2][robot_num]))):
                self.step_Current_Point()
                return True
            else:
                return False

    def get_Status(self):
        return self.finished

    def move_Forward(self, distance):
        curX = self.target_points[self.totalPoints][0]
        curY = self.target_points[self.totalPoints][1]
        curT = self.target_points[self.totalPoints][2]
        addX = distance * math.cos(curT)
        addY = distance * math.sin(curT)
        self.add_Target_Point((curX+addX),(curY+addY),(curT*180/3.14))
    
    def turn(self,by):
        if(by<=180):
            curX = self.target_points[self.totalPoints][0]
            curY = self.target_points[self.totalPoints][1]
            curT = self.target_points[self.totalPoints][2]*180/3.14
            curT = (curT + by)%360
            self.add_Target_Point((curX),(curY),(curT))

robotList = []
namesList = []
t_end = time.time() + 60 * 5

def Fill_Start_Array():
    start_Array = np.array([[],[],[]])
    for robot in robotList:
        start_Array = np.append(start_Array,robot.get_Output_Points(), axis = 1)
    return start_Array

def Update_Target_Array(pos):
    target_Array = np.array([[],[],[]])
    for i in range(len(robotList)):
        robotList[i].check_Position(i,pos)
        target_Array = np.append(target_Array,robotList[i].get_Output_Points(), axis = 1)
    return target_Array

def Check_if_All_Done():
    for robot in robotList:
        if(robot.get_Status() == False):
            return False
    return True

def New_Robot(name, x,y,t):
    namesList.append(name)
    robotList.append(Robot(name,x,y,t))

def Add_Target_Point(name, x,y,t):
    robotList[namesList.index(name)].add_Target_Point(x,y,t)   
`;
   return code;
 };
 
//adds a new robot to the array of Robots

 Blockly.Python['new_robot'] = function(block) {
  var text_name = block.getFieldValue('name');
  var number_x_val = block.getFieldValue('x_val');
  var number_y_val = block.getFieldValue('y_val');
  var angle_theta = block.getFieldValue('theta');
  var value_name = Blockly.Python.valueToCode(block, 'NAME', Blockly.Python.ORDER_ATOMIC);
   var code = `
New_Robot("`+text_name+`",`+number_x_val+`,`+number_y_val+`,`+angle_theta+`)
`;
   return code;
 };

 Blockly.Python['run_to_point'] = function(block) {
   var text_name = block.getFieldValue('name');
   var number_target_x = block.getFieldValue('target_x');
   var number_target_y = block.getFieldValue('target_y');
   var code = `
Add_Target_Point("`+text_name+`",`+number_target_x+`,`+number_target_y+`,0)
`;
   return code;
 };

 Blockly.Python['display_image'] = function(block) {
  var value_image_name = block.getFieldValue('image name');
  // TODO: Assemble Python into code variable.
  var code = `gt_img = plt.imread("`+ String(value_image_name) +`.png")
x_img = np.linspace(-1.0, 1.0, gt_img.shape[1])
y_img = np.linspace(-1.0, 1.0, gt_img.shape[0])
gt_img_handle = r.axes.imshow(gt_img, extent=(-1, 1, -1, 1))
`;
  return code;
 };

//Runs the while loop of the program and makes final safety checks
Blockly.Python['end'] = function(block) {
  var code = `
r = robotarium.Robotarium(number_of_robots=len(robotList), show_figure=True, initial_conditions=Fill_Start_Array(), sim_in_real_time=False)
unicycle_position_controller = create_hybrid_unicycle_pose_controller()
uni_barrier_cert = create_unicycle_barrier_certificate()
x = r.get_poses()
r.step()

while time.time() < t_end:
    x = r.get_poses()
    dxu = unicycle_position_controller(x, Update_Target_Array(x))
    dxu = uni_barrier_cert(dxu, x)
    r.set_velocities(np.arange(len(robotList)), dxu)    
    r.step()
    if(Check_if_All_Done()):
        break

r.call_at_scripts_end()
`;
  return code;
};

//draws a dot at the robot's position (deprecated)
Blockly.Python['pen_down'] = function(block) {
  // TODO: Assemble Python into code variable.
  var code = `line = r.axes.plot(target_values[0],terget_values[1],color='green', marker='o', linestyle='dashed', linewidth=1, markersize=6)
  `;
  return code;
};

//Drives the robot to a point at a specified angle
Blockly.Python['run_to_point_and_angle'] = function(block) {
  var text_name = block.getFieldValue('name');
  var number_target_x = block.getFieldValue('target_x');
  var number_target_y = block.getFieldValue('target_y');
  var angle_angle = block.getFieldValue('angle');
  var code =`
Add_Target_Point("`+text_name+`",`+number_target_x+`,`+number_target_y+`,`+angle_angle+`)
`;
  return code;
};

Blockly.Python['drawing_type'] = function(block) {
  var dropdown_d_type = block.getFieldValue('D_type');
  // TODO: Assemble Python into code variable.
  var code = '...\n';
  return code;
};

Blockly.Python['turn_by_angle'] = function(block) {
  var text_name = block.getFieldValue('name');
  var angle_angle = block.getFieldValue('angle');
  // TODO: Assemble Python into code variable.
  var code = `
robotList[namesList.index(`+text_name+`)].turn(`+angle_angle+`)
`;
  return code;
};

Blockly.Python['move_forward'] = function(block) {
  var text_name = block.getFieldValue('name');
  var number_distance = block.getFieldValue('distance');
  var code = `
robotList[namesList.index("`+text_name+`")].move_Forward(`+number_distance+`)
`;
  return code;
};